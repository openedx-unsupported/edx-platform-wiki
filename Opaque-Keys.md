# Background

Our database uses keys that contain structured data: our Mongo keys are literally JSON objects, with key-value pairs for `tag`, `org`, `course`, `category`, `name`, and `revision`. XModule provides two different abstraction layers over these Mongo keys: `Location`, which is used by "old Mongo", and `Locator`, which is used by "split Mongo". (Because they refer to data in the same database, a Locator can be transformed into a Location, and vice versa -- although doing so is nontrivial, since the two classes contain different data.)

# The Problem

We pass around Location and Locator objects throughout our codebase, as reference to the actual data in Mongo; this is fine. However, in addition to simply passing these objects around, we also have lots of code that introspects these objects, pulling out various pieces of information like `course`, `org`, and `name`, and recombining them in various ways for various purposes. As a result, our key abstraction breaks down: rather than merely being a pointer, our application treats these keys as data in their own right, and as a result our application contains all sorts of assumptions and expectations around the API that these keys support to access that data, what data is available, how to modify one key to create a different key, and so on.

This makes it difficult or impossible to effectively reason about how we store our data, and creates nasty ties between the data storage layer and the presentation layer. (For example, the way that Studio structures its URLs is highly dependent on the org/course/name triple that is present in our keys, and those three components are parsed separately from the URL.) It means that different parts of our application can only accept Locations or only accept Locators, which is odd since they should refer to the same data. It means we must spend time converting from one key abstraction to another, maintaing a loc_mapper data structure for the sole purpose of remembering which Location refers to which Locator and vice versa -- which means lots of extra database queries and performance penalties. It also makes reasoning about how we store our data much more difficult.

# Proposed Solution

To solve this problem, we will convert these "transparent keys" (keys where the application can and does see the internal structure) into "opaque keys" (keys where the application can't, or chooses not to, get any information about the internal structure). In effect, the goal is to make a key do one thing and one thing only: point to a specific database record. It cannot provide information directly about the record in any way: no org/course/name, no "draft" vs "direct", nothing. This will restore the traditional database key abstraction, and greatly simplify how we interact with our data.

Parts of our application that currently introspect the key object will have several options for how they can be refactored:

1. The first and best option is to simply not use any information about the key, but only treat it as a pointer. If the application needs to do a database lookup to get information it needs, that's fine; but it will not get information from the key itself.
2. The second option is to examine the larger scope of the problem, and see if the function's caller has done a database lookup to get the information that the function needs: if so, the code can be refactored so that the function accepts the database object rather than the key object. The database object can and should be introspected, because it contains all the information for that record.
3. The third option is to use the key introspection API, as detailed below.

# Key Introspection API

Because not all of our application can be refactored to treat keys as truly opaque, we will create some kind of key introspection API that all of our database key abstractions (Locations and Locators) support. Most likely, this API will be very similar to the `.get()` method present on Python dictionaries, to keep it familiar and concise. The purpose of this API will be to allow parts of the application to indirectly introspect database keys, which (a) allows the application to get the information it needs, and (b) ensures that all requests for this information funnel through a single (or a very small number of) functions. This way, if we need to change the way that the database stores its data, we can do that behind an abstraction layer, and be confident that the rest of the application won't notice. It also means that multiple database key abstractions (Locations and Locators) can support the same API, so that the rest of the application can treat them as interchangeable, in classic Python duck-typing fashion.