# Background

Our database uses keys that contain structured data: our Mongo keys are literally JSON objects, with key-value pairs for `tag`, `org`, `course`, `category`, `name`, and `revision`. XModule provides two different abstraction layers over these Mongo keys: `Location`, which is used by "old Mongo", and `Locator`, which is used by "split Mongo". (Because they refer to data in the same database, a Locator can be transformed into a Location, and vice versa -- although doing so is nontrivial, since the two classes contain different data.)

# The Problem

We pass around Location and Locator objects throughout our codebase, as reference to the actual data in Mongo; this is fine. However, in addition to simply passing these objects around, we also have lots of code that introspects these objects, pulling out various pieces of information like `course`, `org`, and `name`, and recombining them in various ways for various purposes. As a result, our key abstraction breaks down: rather than merely being a pointer, our application treats these keys as data in their own right, and as a result our application contains all sorts of assumptions and expectations around the API that these keys support to access that data, what data is available, how to modify one key to create a different key, and so on.

This makes it difficult or impossible to effectively reason about how we store our data, and creates nasty ties between the data storage layer and the presentation layer. (For example, the way that Studio structures its URLs is highly dependent on the org/course/name triple that is present in our keys, and those three components are parsed separately from the URL.) It means that different parts of our application can only accept Locations or only accept Locators, which is odd since they should refer to the same data. It means we must spend time converting from one key abstraction to another, maintaing a loc_mapper data structure for the sole purpose of remembering which Location refers to which Locator and vice versa -- which means lots of extra database queries and performance penalties. It also makes reasoning about how we store our data much more difficult.
