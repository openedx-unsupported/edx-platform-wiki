#如何让一个`Pull Request`变基

[原文在此](https://github.com/edx/edx-platform/wiki/How-to-Rebase-a-Pull-Request)

当很多人同时在一个工程上工作的时候，`pull request`可以快速保持稳定。一个“稳定”的`pull request`就是一个不再和开发主线保持同步的开发分支，而且它在`merge`到工程里面之前需要被更新。`pull request`之所以要保持稳定的最常见原因是因为冲突的存在：如果两个`pull request`修改了同一个文件中的同一行，一个`pull request`被`merge`之后，没被`merge`的`pull request`现在就出现一个冲突。有时候，一个`pull request`可以在不产生冲突的情况下保持稳定。或许是代码基础中的一个不同文件的改变需要你的`pull request`中做出相应的改变，以保证和新架构一致。又或许是某人意外将失败了的单元测试merge进了主分支时创建了新分支。不管是什么原因，如果你的`pull request`能保持稳定，在你的分支能被merge之前，你需要将你的分支变基到主分支最新版本。

##什么是变基呢？

![Alt text](data:image,local://master.png)

为了理解这个，我们需要首先理解一点`git`运行的原理。一个`git repository`是一个树形结构，树上的每个点都是`commit`。这里有一个简单`repository`的例子：在主分支上它有4个`commit`，每个`commit`都有一个ID（在这里个例子中，ID是`a`,`b`,`c`和`d`）。你会注意到`d`目前是主分支中最新的`commit`（或者称为`HEAD`）。

![Alt text](data:image,local://branch.png)

这里我们有两个分支，`master`和`my-branch`。你会看到`master`和`my-branch`中都包含`a`和`b`提交。然后它们开始分叉：`master`包含`c`和`d`，而`my-branch`包含`e`和`f`。`b`就是所谓的`my-branch`相比较于`master`的`merge-base`，或者更一般的说，就是`base`。这很有意义：你可以看到`my-branch`是基于`master`的一个早期版本。

所以我们称`my-branch`是保持稳定的，而且你想让它和`master`分支的最新版本保持同步。换种说法，`my-branch`需要包含`c`和`d`。你可以做一个`merge`操作，但是这会让这个分支包含一些让查看`pull request`更困难的的怪异`merge commit`。为了不这样，你可以做一个[`rebase`](http://www.git-scm.com/book/en/Git-Branching-Rebasing)操作。

![Alt text](data:image,local://rebase.png)

当你变基（没错，就是这样翻译！）的时候，git会找到你分支的base（在这个例子中是`b`）以及base和HEAD中的所有提交历史（在这个例子中是`e`和`f`）。并且将这些提交历史在你要变基进去的分支（在这个例子中是master）的HEAD上*重演*一遍。参照你的修改，git创建了一些看起来就像是在master分支顶部进行修改的提交历史：在这个图中，这些提交被叫做`e`和`f`。git并不会擦除你之前的提交：`e`和`f`不会有人动的。，而且如果在变基过程中处心啊了某些错误，你可以回到过去，就像没变过基一样。

然而，另外需要注意的一点就是，git只把分支当作是标签。主分支就是主标签指向的，同时也是所有`commit`的父母。当你给一个分支变基的时候，git移动分支标签指向新创建的分支，`my-branch`现在不再指向`f`，而是指向`f'`。回到事物过去的方式，仅仅是改变了分支标签所以它向后指向了`f`。

##修改历史

你会注意到从`f`到`f'`没有一条直接的通路，在其他人看来，历史好像被突然改变了。`c`和``d`被有效注入了`my-branch`分支，就好像它们一直在那里一样。不像其他的版本控制系统，git允许你修改你的项目的历史 -- 但是对这种允许一定要谨慎。我们稍后会讲到这一点。


#我怎么才能变基呢？

好吧，现在你知道变基是什么了，下一步就是学习如何去变。假定你已经fork了`edx-platform`，而且你创建了一个分支。就像这样：

```
git clone https://github.com/my-username/dex-platform.git
cd edx-platform
git checkout -b my-branch
```

在你的分支里你已经做了一些提交，并且将它们push到了Github上，并创建了一个pull request。你经历了code review，回应了别人的评论，然后某人要求你将你的pull request变基，这就是你要做的：

##将官方repo作为一个远程分支（仅仅在第一次的时候这样）

在Git的定义中，远程分支就是你能提交修改的仓库的克隆。当你从官方的`edx/edx-platform`中克隆出一份后。你创建了一个新的，名叫`your-username/edx-platform`的仓库
，但是这两个repo可以互相分享commit。
为了将`edx`添加为一个远程分支，在你的本地仓库中运行：

```
git remote add edx https://github.com/edx/dex-platform.git
```

你可以运行```git remote -v ```来验证是否成功，你应该看到`edx`在你的远程分支列表中。记住：这一步在每个克隆过程中只需要执行一次。

##抓取主分支的最新版本
你的计算机需要从Github上下载关于这个官方repo的信息，这样它就会知道主分支的最新版本。然后你的远程分支就建立好了，这很简单。在你的本地仓库中运行：
```
get fetch edx
```

##Squash你做的改变（可选的）

这一步是可选的，但是很建议你走这一步。这涉及到你在你的分支上所作的所有提交，然后将他们压缩成一个大点的提交。这样做的目的是为了在变基的时候可以更简单地结局冲突，以及让我们来review你的pull request。

为了这样做，我们将会做一个[交互式的变基](https://help.github.com/articles/interactive-rebase)。首先，找到你分支的base。你可以这样来找：
```
git merge-base my-branch master
```
这条命令会返回一个提交哈希。在下面这条命令中使用你得到的哈希：
```
git rebase --interactive $${HASH}
```

举例来说，如果你的merge base是`abc123`，你会运行```git rebase --interactive abc123```。你的文本编辑器会打开一个列举了你对你的分支所作的所有提交的文件。 而且，在每个提交之前都有一个写作`pick`的单词。就像这样：

```
pick 1fc6c95 do something
pick 6b2481b do something else
pick dd1475d changed some things
pick c619268 fixing typos
```

你需要将除了第一行外所有的行之前的“pick”换做“squash”，做完的时候，应当是这样的：

```
pick 1fc6c95 do something
squash 6b2481b do something else
squash dd1475d changed some things
squash c619268 fixing typos
```

保存并关闭这个文件，稍等片刻，一个新的文件会在你的编辑器中弹出来：包含着所有提交的所有信息。随意修改这些提交信息，同样的保存并关闭这个文件。